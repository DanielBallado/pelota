<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AR Physics Master - Multi-Hand</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            background-color: #1e1e1e;
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #000;
        }
        #input_video { 
            display: none; 
        }
        #output_canvas {
            position: absolute;
            left: 0; 
            top: 0;
            width: 100%; 
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        .loading {
            position: absolute;
            top: 50%; 
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px 30px;
            border-radius: 12px;
            text-align: center;
            max-width: 80%;
        }
        .loading strong {
            display: block;
            font-size: 18px;
            margin-bottom: 10px;
        }
        .loading small {
            font-size: 14px;
            opacity: 0.8;
        }
        .spinner {
            border: 3px solid #333;
            border-top: 3px solid #FFD700;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 15px auto 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            max-width: 80%;
            z-index: 20;
            display: none;
        }
    </style>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div class="container">
        <div id="loadingMsg" class="loading">
            <strong>游 AR Basketball Master</strong>
            <div class="spinner"></div>
            <div>Cargando c치mara...</div>
            <small>춰Usa tus manos para encestar!</small>
        </div>
        <div id="errorMsg" class="error">
            <strong>丘멆잺 Error</strong>
            <p id="errorText"></p>
        </div>
        <video id="input_video" playsinline></video>
        <canvas id="output_canvas"></canvas>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const loadingMsg = document.getElementById('loadingMsg');
        const errorMsg = document.getElementById('errorMsg');
        const errorText = document.getElementById('errorText');

        // Configurar canvas seg칰n el tama침o de la ventana
        function resizeCanvas() {
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeCanvas, 100);
        });

        // --- PAR츼METROS DE F칈SICA ---
        const GRAVITY = 0.0008; // Reducido de 0.0015 para ca칤da m치s lenta
        const FRICTION = 0.985; // Reducido de 0.99 para m치s fricci칩n
        const BOUNCE = 0.75; // Aumentado de 0.6 para mejor rebote
        const MIN_BOUNCE_VELOCITY = 0.003; // Velocidad m칤nima para rebotar
        const HIT_FORCE_MULTIPLIER = 1.5;

        // --- OBJETO PELOTA ---
        let ball = {
            x: 0.5, y: 0.3,
            vx: 0, vy: 0,
            radius: 0.065, // Un poco m치s peque침a para basketball
            color: '#FF6B35', // Naranja tipo basketball
            isDragging: false,
            draggingHandId: null,
            lastX: 0.5, lastY: 0.5
        };

        // --- CANASTAS DE BASKETBALL ---
        const baskets = [
            { x: 0.2, y: 0.15, width: 0.15, rimY: 0.18, scored: false },
            { x: 0.65, y: 0.15, width: 0.15, rimY: 0.18, scored: false }
        ];

        let score = 0;

        // --- ESTADOS DE MANO ---
        const handStates = {};

        function calculateDistance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }

        function updatePhysics() {
            if (!ball.isDragging) {
                ball.vy += GRAVITY;
                ball.vx *= FRICTION;
                ball.vy *= FRICTION;
                ball.x += ball.vx;
                ball.y += ball.vy;

                const r = ball.radius;
                
                // MANTENER LA PELOTA 100% DENTRO DE LA PANTALLA
                // L칤mite inferior - SIEMPRE REBOTA
                if (ball.y + r > 1) { 
                    ball.y = 1 - r;
                    // Si tiene velocidad m칤nima, rebota, sino le damos un peque침o impulso
                    if (Math.abs(ball.vy) < MIN_BOUNCE_VELOCITY) {
                        ball.vy = -MIN_BOUNCE_VELOCITY * 3; // Impulso peque침o hacia arriba
                    } else {
                        ball.vy *= -BOUNCE;
                    }
                }
                // L칤mite superior
                if (ball.y - r < 0) { 
                    ball.y = r; 
                    ball.vy *= -BOUNCE; 
                }
                // L칤mite derecho
                if (ball.x + r > 1) { 
                    ball.x = 1 - r; 
                    ball.vx *= -BOUNCE; 
                }
                // L칤mite izquierdo
                if (ball.x - r < 0) { 
                    ball.x = r; 
                    ball.vx *= -BOUNCE; 
                }

                // Verificar anotaci칩n en canastas
                checkBasketScore();
            } else {
                // TAMBI칄N LIMITAR CUANDO SE EST츼 ARRASTRANDO
                const r = ball.radius;
                if (ball.x + r > 1) ball.x = 1 - r;
                if (ball.x - r < 0) ball.x = r;
                if (ball.y + r > 1) ball.y = 1 - r;
                if (ball.y - r < 0) ball.y = r;
            }
        }

        function checkBasketScore() {
            for (let basket of baskets) {
                const basketCenterX = basket.x + basket.width / 2;
                const rimY = basket.rimY;
                
                // Verificar si la pelota est치 dentro del 치rea horizontal de la canasta
                const isInBasketX = ball.x > basket.x && ball.x < (basket.x + basket.width);
                
                // Verificar si la pelota est치 pasando por el aro (bajando)
                const isAtRim = ball.y > rimY && ball.y < rimY + 0.05;
                const isGoingDown = ball.vy > 0;
                
                if (isInBasketX && isAtRim && isGoingDown && !basket.scored) {
                    // 춰CANASTA!
                    basket.scored = true;
                    score++;
                    ball.color = '#00FF00'; // Verde al anotar
                    
                    // Efecto visual
                    setTimeout(() => {
                        ball.color = '#FF6B35'; // Volver a naranja
                        basket.scored = false; // Resetear para poder anotar de nuevo
                    }, 500);
                }
            }
        }

        function resolveFingerCollision(fingerX, fingerY, handId) {
            const ballRadius = ball.radius;
            const fingerRadius = 0.03;

            const dist = calculateDistance(fingerX, fingerY, ball.x, ball.y);
            const minDist = ballRadius + fingerRadius;

            if (dist < minDist) {
                const dx = ball.x - fingerX;
                const dy = ball.y - fingerY;
                const nx = dx / dist;
                const ny = dy / dist;

                const overlap = minDist - dist;
                ball.x += nx * overlap;
                ball.y += ny * overlap;

                const lastState = handStates[handId];
                if (lastState) {
                    const fingerVx = fingerX - lastState.lastFingerX;
                    const fingerVy = fingerY - lastState.lastFingerY;

                    ball.vx += (fingerVx * HIT_FORCE_MULTIPLIER) + (nx * 0.01);
                    ball.vy += (fingerVy * HIT_FORCE_MULTIPLIER) + (ny * 0.01);
                }

                ball.color = '#FF4500';
                return true;
            }
            return false;
        }

        function onResults(results) {
            loadingMsg.style.display = 'none';
            
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            // Dibujar video ajustado al canvas
            const videoAspect = results.image.width / results.image.height;
            const canvasAspect = canvasElement.width / canvasElement.height;
            
            let drawWidth = canvasElement.width;
            let drawHeight = canvasElement.height;
            let offsetX = 0;
            let offsetY = 0;
            
            if (videoAspect > canvasAspect) {
                drawWidth = canvasElement.height * videoAspect;
                offsetX = (canvasElement.width - drawWidth) / 2;
            } else {
                drawHeight = canvasElement.width / videoAspect;
                offsetY = (canvasElement.height - drawHeight) / 2;
            }
            
            canvasCtx.drawImage(results.image, offsetX, offsetY, drawWidth, drawHeight);

            let anyHandDragging = false;
            const currentFingerPositions = {};

            if (results.multiHandLandmarks) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const landmarks = results.multiHandLandmarks[i];
                    const handId = i;

                    const indexTip = landmarks[8];
                    const thumbTip = landmarks[4];

                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 3});
                    drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 2, radius: 4});

                    const pinchDist = calculateDistance(indexTip.x, indexTip.y, thumbTip.x, thumbTip.y);
                    const isPinching = pinchDist < 0.06;

                    const cursorX = (indexTip.x + thumbTip.x) / 2;
                    const cursorY = (indexTip.y + thumbTip.y) / 2;

                    if (isPinching) {
                        canvasCtx.beginPath();
                        canvasCtx.moveTo(indexTip.x * canvasElement.width, indexTip.y * canvasElement.height);
                        canvasCtx.lineTo(thumbTip.x * canvasElement.width, thumbTip.y * canvasElement.height);
                        canvasCtx.strokeStyle = 'white';
                        canvasCtx.lineWidth = 5;
                        canvasCtx.stroke();
                    }

                    const distToBall = calculateDistance(cursorX, cursorY, ball.x, ball.y);

                    if (ball.isDragging && ball.draggingHandId === handId) {
                        anyHandDragging = true;
                        ball.color = '#00FFFF';

                        // Calcular velocidad pero con l칤mite
                        ball.vx = (cursorX - ball.lastX) * 1.2;
                        ball.vy = (cursorY - ball.lastY) * 1.2;

                        ball.x = cursorX;
                        ball.y = cursorY;
                        
                        // Limitar mientras se arrastra
                        const r = ball.radius;
                        if (ball.x + r > 1) ball.x = 1 - r;
                        if (ball.x - r < 0) ball.x = r;
                        if (ball.y + r > 1) ball.y = 1 - r;
                        if (ball.y - r < 0) ball.y = r;
                        
                        ball.lastX = ball.x;
                        ball.lastY = ball.y;

                    } else if (!ball.isDragging && isPinching && distToBall < ball.radius * 1.3) {
                        ball.isDragging = true;
                        ball.draggingHandId = handId;
                        anyHandDragging = true;
                        ball.color = '#00FFFF';

                        ball.vx = 0;
                        ball.vy = 0;

                        ball.x = cursorX;
                        ball.y = cursorY;
                        ball.lastX = cursorX;
                        ball.lastY = cursorY;
                    }
                    
                    if (!ball.isDragging) {
                        const isColliding = resolveFingerCollision(indexTip.x, indexTip.y, handId);
                        if (!isColliding && !anyHandDragging) {
                            ball.color = '#FF6B35'; // Naranja basketball
                        }
                    }

                    currentFingerPositions[handId] = {
                        lastFingerX: indexTip.x,
                        lastFingerY: indexTip.y
                    };
                }
            }
            
            if (ball.isDragging && !anyHandDragging) {
                ball.isDragging = false;
                ball.draggingHandId = null;
                ball.color = '#FF6B35';
            } else if (!ball.isDragging) {
                ball.color = '#FF6B35';
            }

            Object.assign(handStates, currentFingerPositions);
            for (const handId in handStates) {
                if (!results.multiHandLandmarks || !results.multiHandLandmarks[handId]) {
                    delete handStates[handId];
                }
            }

            updatePhysics();

            // --- RENDERIZADO DE LA PELOTA ---
            const px = ball.x * canvasElement.width;
            const py = ball.y * canvasElement.height;
            const r = ball.radius * Math.min(canvasElement.width, canvasElement.height);

            // Sombra de la pelota
            canvasCtx.beginPath();
            canvasCtx.arc(px, py + 5, r, 0, 2 * Math.PI);
            canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            canvasCtx.fill();

            // Pelota con textura de basketball
            canvasCtx.beginPath();
            canvasCtx.arc(px, py, r, 0, 2 * Math.PI);
            canvasCtx.fillStyle = ball.color;
            canvasCtx.fill();
            
            // L칤neas de basketball
            canvasCtx.strokeStyle = '#000000';
            canvasCtx.lineWidth = 2;
            canvasCtx.beginPath();
            canvasCtx.moveTo(px - r, py);
            canvasCtx.lineTo(px + r, py);
            canvasCtx.stroke();
            
            canvasCtx.beginPath();
            canvasCtx.moveTo(px, py - r);
            canvasCtx.lineTo(px, py + r);
            canvasCtx.stroke();
            
            // Borde blanco
            canvasCtx.beginPath();
            canvasCtx.arc(px, py, r, 0, 2 * Math.PI);
            canvasCtx.lineWidth = 3;
            canvasCtx.strokeStyle = 'white';
            canvasCtx.stroke();
            canvasCtx.restore();
        }

        function showError(message) {
            errorText.textContent = message;
            errorMsg.style.display = 'block';
            loadingMsg.style.display = 'none';
        }

        // Inicializar MediaPipe Hands
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });
        
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 0, // M치s ligero para m칩viles
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });
        
        hands.onResults(onResults);

        // Inicializar c치mara con configuraci칩n m칩vil optimizada
        async function startCamera() {
            try {
                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                
                const constraints = {
                    video: {
                        facingMode: 'user',
                        width: isMobile ? { ideal: 640 } : { ideal: 1280 },
                        height: isMobile ? { ideal: 480 } : { ideal: 720 }
                    }
                };

                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                videoElement.srcObject = stream;
                videoElement.setAttribute('playsinline', '');
                videoElement.setAttribute('webkit-playsinline', '');
                
                await videoElement.play();

                async function detectFrame() {
                    if (videoElement.readyState === videoElement.HAVE_ENOUGH_DATA) {
                        await hands.send({ image: videoElement });
                    }
                    requestAnimationFrame(detectFrame);
                }
                
                detectFrame();
                
            } catch (err) {
                console.error('Error al iniciar c치mara:', err);
                showError('No se pudo acceder a la c치mara. Por favor, permite el acceso y recarga la p치gina.');
            }
        }

        // Iniciar cuando el DOM est칠 listo
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', startCamera);
        } else {
            startCamera();
        }
    </script>
</body>
</html>
