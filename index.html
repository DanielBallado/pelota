<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AR Ping Pong - Hand Game</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            background-color: #1a472a;
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #0a2515;
        }
        #input_video { 
            display: none; 
        }
        #output_canvas {
            position: absolute;
            left: 0; 
            top: 0;
            width: 100%; 
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        .loading {
            position: absolute;
            top: 50%; 
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px 30px;
            border-radius: 12px;
            text-align: center;
            max-width: 80%;
        }
        .loading strong {
            display: block;
            font-size: 18px;
            margin-bottom: 10px;
        }
        .loading small {
            font-size: 14px;
            opacity: 0.8;
        }
        .spinner {
            border: 3px solid #333;
            border-top: 3px solid #4CAF50;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 15px auto 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            z-index: 15;
            display: none;
            border: 3px solid #FFD700;
        }
        .game-over h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #FFD700;
        }
        .game-over p {
            font-size: 24px;
            margin: 10px 0;
        }
        .game-over button {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
        }
        .game-over button:active {
            transform: scale(0.95);
        }
    </style>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div class="container">
        <div id="loadingMsg" class="loading">
            <strong>游끱 AR Ping Pong</strong>
            <div class="spinner"></div>
            <div>Cargando c치mara...</div>
            <small>춰Usa tus manos como raquetas!</small>
        </div>
        
        <div id="gameOver" class="game-over">
            <h1 id="winnerText">游끥 춰GANADOR!</h1>
            <p id="finalScore"></p>
            <button onclick="resetGame()">游댃 Jugar de Nuevo</button>
        </div>
        
        <video id="input_video" playsinline></video>
        <canvas id="output_canvas"></canvas>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const loadingMsg = document.getElementById('loadingMsg');
        const gameOverDiv = document.getElementById('gameOver');
        const winnerText = document.getElementById('winnerText');
        const finalScore = document.getElementById('finalScore');

        // Configurar canvas
        function resizeCanvas() {
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeCanvas, 100);
        });

        // --- PAR츼METROS DE F칈SICA (SIN GRAVEDAD - PING PONG REAL) ---
        const FRICTION = 0.995; // Muy poca fricci칩n para que mantenga velocidad
        const BOUNCE = 0.95; // Rebote casi perfecto en todas las paredes
        const HIT_FORCE_MULTIPLIER = 0.8; // Golpes suaves
        const MAX_SPEED = 0.012; // L칤mite de velocidad

        // --- OBJETO PELOTA ---
        let ball = {
            x: 0.5, y: 0.5,
            vx: 0.005, vy: 0.003, // Velocidad inicial lenta
            radius: 0.045, // Pelota m치s grande
            color: '#FFFFFF',
            lastHitBy: null // Para evitar golpes m칰ltiples
        };

        // --- ESTADOS DE MANO ---
        const handStates = {};
        
        // --- PUNTUACI칍N ---
        let scoreLeft = 0;
        let scoreRight = 0;
        const WINNING_SCORE = 5;
        let gameActive = true;

        function calculateDistance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }

        function limitSpeed() {
            const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
            if (speed > MAX_SPEED) {
                ball.vx = (ball.vx / speed) * MAX_SPEED;
                ball.vy = (ball.vy / speed) * MAX_SPEED;
            }
        }

        function updatePhysics() {
            if (!gameActive) return;

            // SIN GRAVEDAD - f칤sica de ping pong real
            ball.vx *= FRICTION;
            ball.vy *= FRICTION;
            
            limitSpeed(); // Limitar velocidad m치xima
            
            ball.x += ball.vx;
            ball.y += ball.vy;

            const r = ball.radius;
            
            // TODAS las paredes rebotan igual (superior e inferior)
            // L칤mite inferior - REBOTA IGUAL QUE LAS DEM츼S
            if (ball.y + r > 1) { 
                ball.y = 1 - r; 
                ball.vy *= -BOUNCE; // Rebote normal
            }
            
            // L칤mite superior - REBOTA
            if (ball.y - r < 0) { 
                ball.y = r; 
                ball.vy *= -BOUNCE; 
            }
            
            // L칤mites izquierdo y derecho (PUNTO!)
            if (ball.x - r < 0) {
                // Punto para el jugador DERECHO
                scoreRight++;
                checkWinner();
                resetBall('right');
            }
            if (ball.x + r > 1) {
                // Punto para el jugador IZQUIERDO
                scoreLeft++;
                checkWinner();
                resetBall('left');
            }
        }

        function resetBall(lastScorer) {
            // Resetear pelota al centro
            ball.x = 0.5;
            ball.y = 0.5;
            
            // Direcci칩n hacia el que NO anot칩
            if (lastScorer === 'left') {
                ball.vx = 0.005; // Hacia la derecha
            } else {
                ball.vx = -0.005; // Hacia la izquierda
            }
            ball.vy = (Math.random() - 0.5) * 0.004; // Algo de variaci칩n vertical
            ball.lastHitBy = null;
        }

        function checkWinner() {
            if (scoreLeft >= WINNING_SCORE) {
                endGame('IZQUIERDA');
            } else if (scoreRight >= WINNING_SCORE) {
                endGame('DERECHA');
            }
        }

        function endGame(winner) {
            gameActive = false;
            winnerText.textContent = `游끥 춰GAN칍 ${winner}!`;
            finalScore.textContent = `Marcador Final: ${scoreLeft} - ${scoreRight}`;
            gameOverDiv.style.display = 'block';
        }

        function resetGame() {
            scoreLeft = 0;
            scoreRight = 0;
            gameActive = true;
            gameOverDiv.style.display = 'none';
            resetBall('right');
        }
        window.resetGame = resetGame; // Hacer accesible globalmente

        function resolveHandCollision(handX, handY, handId, isLeft) {
            // Evitar que la misma mano golpee m칰ltiples veces seguidas
            if (ball.lastHitBy === handId) return false;

            const handRadius = 0.1; // 츼rea de golpeo m치s grande para pelota m치s grande
            const dist = calculateDistance(handX, handY, ball.x, ball.y);

            if (dist < ball.radius + handRadius) {
                const dx = ball.x - handX;
                const dy = ball.y - handY;
                const nx = dx / dist;
                const ny = dy / dist;

                // Empujar la pelota
                const overlap = (ball.radius + handRadius) - dist;
                ball.x += nx * overlap * 1.5;
                ball.y += ny * overlap * 1.5;

                // Transferencia de velocidad
                const lastState = handStates[handId];
                if (lastState) {
                    const handVx = handX - lastState.lastHandX;
                    const handVy = handY - lastState.lastHandY;

                    ball.vx = (handVx * HIT_FORCE_MULTIPLIER) + (nx * 0.008);
                    ball.vy = (handVy * HIT_FORCE_MULTIPLIER) + (ny * 0.008);
                }

                ball.lastHitBy = handId;
                ball.color = isLeft ? '#FF6B6B' : '#4ECDC4'; // Rojo o Cyan seg칰n lado
                
                setTimeout(() => {
                    ball.color = '#FFFFFF';
                    ball.lastHitBy = null;
                }, 200);

                return true;
            }
            return false;
        }

        function onResults(results) {
            loadingMsg.style.display = 'none';
            
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            // Dibujar video
            const videoAspect = results.image.width / results.image.height;
            const canvasAspect = canvasElement.width / canvasElement.height;
            
            let drawWidth = canvasElement.width;
            let drawHeight = canvasElement.height;
            let offsetX = 0;
            let offsetY = 0;
            
            if (videoAspect > canvasAspect) {
                drawWidth = canvasElement.height * videoAspect;
                offsetX = (canvasElement.width - drawWidth) / 2;
            } else {
                drawHeight = canvasElement.width / videoAspect;
                offsetY = (canvasElement.height - drawHeight) / 2;
            }
            
            canvasCtx.drawImage(results.image, offsetX, offsetY, drawWidth, drawHeight);

            // --- DIBUJAR RED EN EL CENTRO ---
            const netSegments = 20;
            canvasCtx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            canvasCtx.lineWidth = 3;
            for (let i = 0; i < netSegments; i++) {
                if (i % 2 === 0) {
                    canvasCtx.beginPath();
                    canvasCtx.moveTo(canvasElement.width / 2, (i / netSegments) * canvasElement.height);
                    canvasCtx.lineTo(canvasElement.width / 2, ((i + 1) / netSegments) * canvasElement.height);
                    canvasCtx.stroke();
                }
            }

            // --- DIBUJAR MARCADOR ---
            canvasCtx.font = 'bold 60px Arial';
            canvasCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            canvasCtx.strokeStyle = 'black';
            canvasCtx.lineWidth = 4;
            
            // Marcador izquierdo
            const leftScoreX = canvasElement.width * 0.25;
            const scoreY = 80;
            canvasCtx.strokeText(scoreLeft, leftScoreX, scoreY);
            canvasCtx.fillText(scoreLeft, leftScoreX, scoreY);
            
            // Marcador derecho
            const rightScoreX = canvasElement.width * 0.75;
            canvasCtx.strokeText(scoreRight, rightScoreX, scoreY);
            canvasCtx.fillText(scoreRight, rightScoreX, scoreY);

            // --- PROCESAR MANOS ---
            const currentHandPositions = {};

            if (results.multiHandLandmarks && results.multiHandedness) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const landmarks = results.multiHandLandmarks[i];
                    const handedness = results.multiHandedness[i];
                    const isLeft = handedness.label === 'Left'; // En espejo, Left es derecha real
                    const handId = i;

                    // Obtener centro de la palma (promedio de varios puntos)
                    const wrist = landmarks[0];
                    const indexMcp = landmarks[5];
                    const pinkyMcp = landmarks[17];
                    
                    const palmX = (wrist.x + indexMcp.x + pinkyMcp.x) / 3;
                    const palmY = (wrist.y + indexMcp.y + pinkyMcp.y) / 3;

                    // Dibujar mano con color seg칰n lado
                    const handColor = isLeft ? '#FF6B6B' : '#4ECDC4';
                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: handColor, lineWidth: 3});
                    drawLandmarks(canvasCtx, landmarks, {color: '#FFFFFF', lineWidth: 2, radius: 4});

                    // Dibujar 치rea de golpeo
                    canvasCtx.beginPath();
                    canvasCtx.arc(palmX * canvasElement.width, palmY * canvasElement.height, 
                                  0.1 * canvasElement.width, 0, 2 * Math.PI);
                    canvasCtx.strokeStyle = handColor;
                    canvasCtx.lineWidth = 3;
                    canvasCtx.stroke();

                    // Detectar colisi칩n con la pelota
                    if (gameActive) {
                        resolveHandCollision(palmX, palmY, handId, isLeft);
                    }

                    // Guardar posici칩n para pr칩ximo frame
                    currentHandPositions[handId] = {
                        lastHandX: palmX,
                        lastHandY: palmY
                    };
                }
            }

            Object.assign(handStates, currentHandPositions);
            for (const handId in handStates) {
                if (!results.multiHandLandmarks || !results.multiHandLandmarks[handId]) {
                    delete handStates[handId];
                }
            }

            updatePhysics();

            // --- RENDERIZAR PELOTA ---
            const px = ball.x * canvasElement.width;
            const py = ball.y * canvasElement.height;
            const r = ball.radius * Math.min(canvasElement.width, canvasElement.height);

            // Sombra
            canvasCtx.beginPath();
            canvasCtx.arc(px + 3, py + 3, r, 0, 2 * Math.PI);
            canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            canvasCtx.fill();

            // Pelota
            canvasCtx.beginPath();
            canvasCtx.arc(px, py, r, 0, 2 * Math.PI);
            canvasCtx.fillStyle = ball.color;
            canvasCtx.fill();
            
            // Borde
            canvasCtx.strokeStyle = '#FFD700';
            canvasCtx.lineWidth = 3;
            canvasCtx.stroke();

            canvasCtx.restore();
        }

        // Inicializar MediaPipe Hands
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });
        
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 0,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });
        
        hands.onResults(onResults);

        // Inicializar c치mara
        async function startCamera() {
            try {
                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                
                const constraints = {
                    video: {
                        facingMode: 'user',
                        width: isMobile ? { ideal: 640 } : { ideal: 1280 },
                        height: isMobile ? { ideal: 480 } : { ideal: 720 }
                    }
                };

                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                videoElement.srcObject = stream;
                videoElement.setAttribute('playsinline', '');
                videoElement.setAttribute('webkit-playsinline', '');
                
                await videoElement.play();

                async function detectFrame() {
                    if (videoElement.readyState === videoElement.HAVE_ENOUGH_DATA) {
                        await hands.send({ image: videoElement });
                    }
                    requestAnimationFrame(detectFrame);
                }
                
                detectFrame();
                
            } catch (err) {
                console.error('Error al iniciar c치mara:', err);
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', startCamera);
        } else {
            startCamera();
        }
    </script>
</body>
</html>
